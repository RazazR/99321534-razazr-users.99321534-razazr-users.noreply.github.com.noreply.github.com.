The parser is only available in the full build (i.e. not in "noparse" builds). Compliant with the protobuf parser to the following extend:

* Required, optional, repeated and packed repeated fields:

  ```protobuf
  message Test {
      required int32 a = 1;
      optional int32 b = 2 [default=100];
      repeated int32 c = 3;
      repeated int32 c = 4 [packed=true];
  }
  ```

* Data types: int32, uint32, sint32, fixed32, sfixed32, int64, uint64, sint64, fixed64, sfixed64, bool, enum, string,
  bytes, messages, embedded messages, float, double
  
  ```protobuf
  message Test {
      required int32 a = 1; // Varint encoded
      required uint32 b = 2; // Varint encoded
      required sint32 c = 3; // Varint zigzag encoded
      required bool d = 4; // Varint encoded
    
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
    
      optional Priority e = 5 [default=MEDIUM]; // Varint encoded
      required string f = 6; // Varint length delimited
      required bytes g = 7; // Varint length delimited
      required Embedded h = 8; // Varint length delimited
    
      message Embedded {
          repeated int32 a = 1; // Multiple tags
          repeated int32 b = 2 [packed=true]; // One tag, length delimited
          
          required sfixed32 c = 3; // Fixed 4 bytes int32
          required fixed32 d = 4; // Fixed 4 bytes uint32
          required float e = 5; // Fixed 4 bytes
          required double f = 6; // Fixed 8 bytes
          
          // Through ByteBuffer.js loaded with Long.js:
          optional int64 g = 7; // Varint encoded
          optional uint64 h = 8; // Varint encoded
          optional sint64 i = 9; // Varint zigzag encoded
          required sfixed64 j = 10; // Fixed 8 bytes int64
          required fixed64 k = 11; // Fixed 8 bytes uint64
      }
  }
  ```
  
* Packages

  ```protobuf
  package My.Game;
  
  message Test {
      ...
  }
  
  message Test2 {
      required My.Game.Test test = 1;
  }
  ```
  
* Qualified and fully qualified name resolving:

  ```protobuf
  package My.Game;
  
  message Test {
      ...
      
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
  }
  
  message Test2 {
      required .My.Game.Test.Priority priority_fqn = 1 [default=LOW];
      required Test.Priority priority_qn = 2 [default=MEDIUM];
  }
  ```

* Options on all levels:
  
  ```protobuf
  option toplevel_1 = 10;
  option toplevel_2 = "Hello!";
  
  message Test {
      option inmessage = "World!";
      optional int32 somenumber = 1 [default=123]; // Actually the only one used
  }
  ```
  
  Paranthesis around option names, like `option (inmessage) = ...` are ignored for compatibility with custom options.
  Accessing arbitrary options on namespace objects emitted by a builder is also possible (requires an ECMAScript 5 /
  Javascript 1.8.5 compatible environment, e.g. node.js or any modern browser):
  
  ```javascript
  ...
  var root = builder.build();
  console.log(root.$options); // { 'toplevel_1': 10, 'toplevel_2': 'Hello!' }
  console.log(root.Test.$options); // { 'inmessage': 'World!' }
  ```

* Imports:

  ```protobuf
  package My; // Not used by the following imports
  import public "example1.proto"; // The "public" keyword is ignored
  import "example2.proto";
  
  message Test2 {
      required Test1 test1 = 0; // Unique name
      required .Test2 test2 = 1; // Duplicate name resolved absolutely
  }
  ```
  
  See also: [example1.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example1.proto),
  [example2.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example2.proto)
  
  ```javascript
  var builder = ProtoBuf.protoFromFile("tests/imports.proto");
  var root = builder.build();
  // root now contains:
  // - .Test1
  // - .Test2
  // - .My.Test2 using .Test1 for field 'test1' and .Test2 for field 'test2'
  ```
  
  **NOTE:** Importing .proto files is available in the full build (not in the noparse build) only. Importing the .json
  counterpart of a .proto file (e.g. generated by proto2js) is supported regardless of the build you are using. Imports
  are also always fetched *synchronously*, so it's a good idea to package everything into a single file when using it in
  the browser.
  
* Extensions:
  
  ```protobuf
  extend something {
      ...
  }
  ```
  
  ```protobuf
  import "google/protobuf/descriptor.proto";
  ```
  
  These statements are actually simply ignored to make existing definitions compile fine. Low-level bootstrapping
  is not required by ProtoBuf.js.
  
#### Not (yet) supported ####
* *Extensions* (what for?) and *services* (you roll your own, don't you?). If you need anything of this, please open an
  issue and explain your exact requirements. It's just that I have no idea how to benefit from that and therefore I am
  not sure how to design it.

Calling the parser on your own
------------------------------

```javascript
var ProtoBuf = require("protobufjs"),
    fs = require("fs"),
    util = require("util");

var parser = new ProtoBuf.DotProto.Parser(fs.readFileSync("tests/complex.proto"));
var ast = parser.parse();
console.log(util.inspect(ast, false, null, true));
```