The **Parser** is only available in the full build (i.e. not in "light" builds). It's compliant with the [official protobuf implementation](https://developers.google.com/protocol-buffers/docs/proto) to the following extent:

* Required, optional, repeated and packed repeated fields:

  ```protobuf
  message Test {
      required int32 a = 1;
      optional int32 b = 2 [default=100];
      repeated int32 c = 3;
      repeated int32 c = 4 [packed=true];
  }
  ```

* Data types: int32, uint32, sint32, fixed32, sfixed32, int64, uint64, sint64, fixed64, sfixed64, bool, enum, string,
  bytes, messages, embedded messages, legacy groups, float, double
  
  ```protobuf
  message Test {
      required int32 a = 1; // Varint encoded
      required uint32 b = 2; // Varint encoded
      required sint32 c = 3; // Varint zigzag encoded
      required bool d = 4; // Varint encoded
    
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
    
      optional Priority e = 5 [default=MEDIUM]; // Varint encoded
      required string f = 6; // Varint length delimited
      required bytes g = 7; // Varint length delimited
      required Embedded h = 8; // Varint length delimited
    
      message Embedded {
          repeated int32 a = 1; // Multiple tags
          repeated int32 b = 2 [packed=true]; // One tag, length delimited
          
          required sfixed32 c = 3; // Fixed 4 bytes int32
          required fixed32 d = 4; // Fixed 4 bytes uint32
          required float e = 5; // Fixed 4 bytes
          required double f = 6; // Fixed 8 bytes
          
          // Through ByteBuffer.js loaded with Long.js:
          optional int64 g = 7; // Varint encoded
          optional uint64 h = 8; // Varint encoded
          optional sint64 i = 9; // Varint zigzag encoded
          required sfixed64 j = 10; // Fixed 8 bytes int64
          required fixed64 k = 11; // Fixed 8 bytes uint64
      }
  }
  ```
  
* Packages

  ```protobuf
  package My.Game;
  
  message Test {
      ...
  }
  
  message Test2 {
      required My.Game.Test test = 1;
  }
  ```
  
* Qualified and fully qualified name resolving:

  ```protobuf
  package My.Game;
  
  message Test {
      ...
      
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
  }
  
  message Test2 {
      required .My.Game.Test.Priority priority_fqn = 1 [default=LOW];
      required Test.Priority priority_qn = 2 [default=MEDIUM];
  }
  ```

* Options on all levels:
  
  ```protobuf
  option toplevel_1 = 10;
  option toplevel_2 = "Hello!";
  
  message Test {
      option inmessage = "World!";
      optional int32 somenumber = 1 [default=123]; // Actually the only one used
  }
  ```
  
  Paranthesis around option names, like `option (inmessage) = ...` are ignored for compatibility with custom options.
  Accessing arbitrary options on namespace objects emitted by a builder is also possible (requires an ECMAScript 5 /
  Javascript 1.8.5 compatible environment, e.g. node.js or any modern browser):
  
  ```javascript
  ...
  var root = builder.build();
  console.log(root.$options); // { 'toplevel_1': 10, 'toplevel_2': 'Hello!' }
  console.log(root.Test.$options); // { 'inmessage': 'World!' }
  ```

* Imports:

  ```protobuf
  package My; // Not used by the following imports
  import public "example1.proto"; // The public keyword is simply ignored
  import "example2.proto";
  
  message Test2 {
      required Test1 test1 = 0; // Unique name
      required .Test2 test2 = 1; // Duplicate name resolved absolutely
  }
  ```
  
  See also: [example1.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example1.proto),
  [example2.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example2.proto)
  
  ```javascript
  var builder = ProtoBuf.loadProtoFile("tests/imports.proto");
  var root = builder.build();
  // root now contains:
  // - .Test1
  // - .Test2
  // - .My.Test2 using .Test1 for field 'test1' and .Test2 for field 'test2'
  ```
  
  **NOTE:** Importing .proto files is available in the full build (not in "light" builds) only. Importing the .json counterpart of a .proto file (e.g. generated by proto2js) is supported regardless of the build you are using. Imports are also always fetched *synchronously*, so it's a good idea to package everything into a single file when using it in the browser.
  
* Extensions:
  
  ```protobuf
  message A {
      a = 1;
  }
  
  message B {
      extend something {
          optional b = 2;
      }
  }
  ```

  Extensions are parsed and applied since 1.4.0. Internal extensions to the ``google.protobuf.*`` namespace  are ignored because low-level bootstrapping is not required by ProtoBuf.js, thus the internal definitions are not present by default. However, if they have been loaded manually, extensions will be applied but will not have any effect on the parser's workflow (like when extending internal structures with a new keyword).

  Since 3.5.0, extension fields use their fully qualified name as their key. Regarding the example above:
  ```js
  a.set(".B.b", 234);
  ```

* Services:

  ```protobuf
  service MyService {
     rpc MyMethod(RequestType) returns(ResponseType);
  }
  ```

* OneOfs:

  ```protobuf
  message MyMessage {
     oneof request {
        CreateRequest create = 1;
        UpdateRequest update = 2;
        DeleteRequest delete = 3;
     }
  }
  ```

  Oneof syntax is supported since 3.7.0. In the example above, there will be a virtual property `MyMessage#request` that holds the name of the field being present, or evaluates to `null` if none is set. If `MyMessage#create` is present, it evaluates to `"create"`.  
  
  **NOTE:** Always use `Message#set(key, value[, noAssert])` to assign values to oneof enclosed fields to ensure that any possibly previously assigned values will be unset and the virtual property adjusted accordingly. Assigning a value to the virtual property has no effect on encoding.

Calling the parser on your own
------------------------------

```javascript
var ProtoBuf = require("protobufjs"),
    fs = require("fs"),
    util = require("util");

var parser = new ProtoBuf.DotProto.Parser(fs.readFileSync("tests/complex.proto"));
var ast = parser.parse();
console.log(util.inspect(ast, false, null, true));
```

#### Testing for a "light" build
```js
...
if (ProtoBuf.DotProto) {
   // full build, parser is available
} else {
   // light build without .proto support
}
...
```

**Next:** [Learn more about pbjs on the command line](https://github.com/dcodeIO/ProtoBuf.js/wiki/pbjs)