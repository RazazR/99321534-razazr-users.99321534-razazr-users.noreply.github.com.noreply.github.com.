The **Parser** is only available in the full build (i.e. not in "noparse" builds). It's compliant with the [official protobuf implementation](https://developers.google.com/protocol-buffers/docs/proto) to the following extent:

* Required, optional, repeated and packed repeated fields:

  ```protobuf
  message Test {
      required int32 a = 1;
      optional int32 b = 2 [default=100];
      repeated int32 c = 3;
      repeated int32 c = 4 [packed=true];
  }
  ```

* Data types: int32, uint32, sint32, fixed32, sfixed32, int64, uint64, sint64, fixed64, sfixed64, bool, enum, string,
  bytes, messages, embedded messages, float, double
  
  ```protobuf
  message Test {
      required int32 a = 1; // Varint encoded
      required uint32 b = 2; // Varint encoded
      required sint32 c = 3; // Varint zigzag encoded
      required bool d = 4; // Varint encoded
    
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
    
      optional Priority e = 5 [default=MEDIUM]; // Varint encoded
      required string f = 6; // Varint length delimited
      required bytes g = 7; // Varint length delimited
      required Embedded h = 8; // Varint length delimited
    
      message Embedded {
          repeated int32 a = 1; // Multiple tags
          repeated int32 b = 2 [packed=true]; // One tag, length delimited
          
          required sfixed32 c = 3; // Fixed 4 bytes int32
          required fixed32 d = 4; // Fixed 4 bytes uint32
          required float e = 5; // Fixed 4 bytes
          required double f = 6; // Fixed 8 bytes
          
          // Through ByteBuffer.js loaded with Long.js:
          optional int64 g = 7; // Varint encoded
          optional uint64 h = 8; // Varint encoded
          optional sint64 i = 9; // Varint zigzag encoded
          required sfixed64 j = 10; // Fixed 8 bytes int64
          required fixed64 k = 11; // Fixed 8 bytes uint64
      }
  }
  ```
  
* Packages

  ```protobuf
  package My.Game;
  
  message Test {
      ...
  }
  
  message Test2 {
      required My.Game.Test test = 1;
  }
  ```
  
* Qualified and fully qualified name resolving:

  ```protobuf
  package My.Game;
  
  message Test {
      ...
      
      enum Priority {
          LOW = 1;
          MEDIUM = 2;
          HIGH = 3;
      }
  }
  
  message Test2 {
      required .My.Game.Test.Priority priority_fqn = 1 [default=LOW];
      required Test.Priority priority_qn = 2 [default=MEDIUM];
  }
  ```

* Options on all levels:
  
  ```protobuf
  option toplevel_1 = 10;
  option toplevel_2 = "Hello!";
  
  message Test {
      option inmessage = "World!";
      optional int32 somenumber = 1 [default=123]; // Actually the only one used
  }
  ```
  
  Paranthesis around option names, like `option (inmessage) = ...` are ignored for compatibility with custom options.
  Accessing arbitrary options on namespace objects emitted by a builder is also possible (requires an ECMAScript 5 /
  Javascript 1.8.5 compatible environment, e.g. node.js or any modern browser):
  
  ```javascript
  ...
  var root = builder.build();
  console.log(root.$options); // { 'toplevel_1': 10, 'toplevel_2': 'Hello!' }
  console.log(root.Test.$options); // { 'inmessage': 'World!' }
  ```

* Imports:

  ```protobuf
  package My; // Not used by the following imports
  import public "example1.proto"; // The public keyword is simply ignored
  import "example2.proto";
  
  message Test2 {
      required Test1 test1 = 0; // Unique name
      required .Test2 test2 = 1; // Duplicate name resolved absolutely
  }
  ```
  
  See also: [example1.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example1.proto),
  [example2.proto](https://github.com/dcodeIO/ProtoBuf.js/tree/master/tests/example2.proto)
  
  ```javascript
  var builder = ProtoBuf.protoFromFile("tests/imports.proto");
  var root = builder.build();
  // root now contains:
  // - .Test1
  // - .Test2
  // - .My.Test2 using .Test1 for field 'test1' and .Test2 for field 'test2'
  ```
  
  **NOTE:** Importing .proto files is available in the full build (not in the noparse build) only. Importing the .json
  counterpart of a .proto file (e.g. generated by proto2js) is supported regardless of the build you are using. Imports
  are also always fetched *synchronously*, so it's a good idea to package everything into a single file when using it in
  the browser.
  
* Extensions:
  
  ```protobuf
  extend something {
      ...
  }
  ```

  Extensions are parsed and applied since 1.4.0. Internal extensions like the following one are ignored because low-level bootstrapping is not required by ProtoBuf.js, thus the ``google.protobuf.*`` definitions are not present by default. However, if they have been loaded manually, extensions will be applied but will not have any effect to the parser's workflow (like when extending internal structures with a new keyword):
  
  ```protobuf
  import "google/protobuf/descriptor.proto";
  ```

* Services:

  ```protobuf
  service MyService {
     rpc MyMethod(RequestType) returns(ResponseType);
  }
  ```

Calling the parser on your own
------------------------------

```javascript
var ProtoBuf = require("protobufjs"),
    fs = require("fs"),
    util = require("util");

var parser = new ProtoBuf.DotProto.Parser(fs.readFileSync("tests/complex.proto"));
var ast = parser.parse();
console.log(util.inspect(ast, false, null, true));
```

#### Testing for a "noparse" build
```js
...
if (ProtoBuf.DotProto) {
   // full build, parser is available
} else {
   // noparse build without .proto support
}
...
```

**Next:** [Learn more about proto2js on the command line](https://github.com/dcodeIO/ProtoBuf.js/wiki/proto2js)